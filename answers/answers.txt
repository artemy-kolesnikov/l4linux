Introduction To Microkernel
1. Каким образом реализована идея “Everything is Object”, в чем этом выражается?
Какждая программа или сервис в системе это изолированный объект. Для работы с объектами системы существует один системный вызов - invoke_object. Параметры системного вызова зависят от типа объекта и передаются через UTCB.

2. Что такое Capability list, зачем он нужен?
Каждый объект в системе имеет свой идентификатор, по которому к нему можно обратиться. Давать возможность объектам обращаться друг к другу не безопасно, поэтому ввели уровень косвенности под названием Capability list. Это таблица, которая существует для каждого объекта в системе и содержит ссылки на идентификаторы объектов, с которым может работать владелец этой таблицы. 

3. Где находится scheduler и почему?
Планировщик находится в ядре, не смотря на то, что это политика, а не маханизм. Это связанно с тем, что реализация планировщика в пространстве пользователя натыкается на некоторые проблемы:
- Ядро будет зависить от приложения, работающего в пространстве пользователя, а это не безопасно.
- Планировщик процессов интенсивно взаимодействует с ядром, и размещение его в пространстве пользователя плохо влияет на производительность.

4. Что такое Sigma0, Moe, Ned, и зачем они нужны?
Moe - загрузчик, который выполняет инициализацию системы и запускает Ned
Ned - аналог процесса Init в *nix.
Sigma0 - базовый pager для всех процессов в L4Re.

5. Что собой представляет L4Re?
Набор программ (политик, т.к. ядро предоставляет только механизмы) поверх ядра L4, в совокупности с ядром L4 представляющих полноценную операционную систему.

6. Что является execution unit в концепции Fiasco.OC?

7. Что такое TCB, чем отличается от UTCB, что такое Kernel Info Block, где находится каждая из этих структур, зачем она нужна и как с ними можно работать?
TCB - область памяти ядра для хранение информации о потоке. Существует для каждого потока
UTCB - расширение для TCB, в котором может храниться любая non trusted информация. Основное использование - передача параметров при системных вызовах.

8. Какие механизмы сериализации доступа к переменным были озвучены в лекции?

9. Что делает и зачем нужны l4_msgtag и l4_ipc_send?
l4_msgtag_t - структура данных, содержащая параметры IPC вызова.
l4_ipc_send - выполнение асинхронного IPC вызова.

IPC, Memory and L4Re
1. Что такое factory, каким образом используется и для чего? 
Объект ядра, который создаёт другие объекты ядра.

2. Что такое target_cap, thread_cap?
target_cap - capability для для создаваемого IPC gate
thread_cap - указывает capability потока, который может получать IPC сообщения через этот IPC gate

3. Область видимости gate
Могу предположить, что gate виден всем объектам, у которых есть capability на указанный при создании target_cap.

4. Структура utcb и назначение каждого из полей 
Используется как буфер передачи данных при системных вызовах.
Состоит из:
Message registers - буфер для передачи данных в ядро (например через него можно передавать параметры системных вызовов)
Buffer registers - используется для хранения дескрипторов flexpage
Thread Control Registers - область для хранения локальной информации о потоке. Заполняется ядром, и не копируется при IPC.

5. Что происходит, когда истекает timeout в ipc?
Управление передаётся вызывающему коду. Возможно с кодом ошибки. Таким образом можно реализовать функцию sleep.

6. Есть ли ограничения на длинну ipc message? 
Не помню этого в лекции, но думаю есть.

7. Что такое IDL compiler, зачем он нужен и какие проблемы решает? Как эти проблемы решены вgnu/ mach (вдруг вы знаете), как он решаются в l4re? 
Нужен для генерации кода RPC клиента и сервера. В l4Re можно использовать DICE IDL компилятор, можно использовать классы на основе iostream для ручной сериализации данных.

8. Communication channel и ipc gate - одно и то же? 
Вроде да.

9. Так все же, каким образом сервер узнают какую dispatch функцию вызывать? А если у нас несколько каналов? 
Для этого используется label.

10. Опишите пожалуйста механизм работы sigma0, каким образом обрабатываются page fault?
Sigma0 - базовый pager для всех процессов в L4Re. В его адресное пространство отображено вся физическая память. Поэтому для этого процесса не возникает page fault. Sigma0 обрабатывает 
IPC сообщения page fault от дочерних процессов и отображает страницы памяти из своего адресного пространства в адресное пространство дочернего процесса.

11. Что такое flexpage и зачем это нужно? 
Структура для описания страницы памяти. Используется pager-ом для обработки page fault.

12. Опишите пожалуйста проблему иерархических мапингов и метод ее решения в fiasco.oc
Если pager-ов у потока несколько, не ясно, какой pager должен обрабытывать page fault процесса. Для решения этой проблемы вводится Region Mapper.
По диапазону адресов он возвращает pager, который обрабатывает page fault на этом адресе.

13. Что такое dataspace, каким образом с этой абстракцией осцществляетс работа?
Абстракция, скрывающая физическое местоположения страницы памяти. Для работы нужно получить capability для dataspace и с помощью Region Manager приатачить dataspace к виртуальной памяти. 

14. Как используюя dataspace передавать данные между серверами? 
Пока не разобрался.

Advanced Components on Top of L4Re Answers

https://github.com/artemy-kolesnikov/l4linux/tree/master/crypt_client_server

1. Опишите пожалуйста подходы к адаптации/использованию существующего кода других ОС в окружении L4Re 
  - Портирование всего приложения.
  - Портирование системный библиотек. (имитирование API ОС, с которой портируют, ОС, на которую портируют)
  - Эмуляция ОС. 
  - Виртуализация.

2. Продемонстриуйте пожалуйста, на примере любой функции POSIX (кроме time) каким образом она реализована, как комуницирует с серверами и как ею пользоваться в программе 

3. Объясните пожалуйста плюсы и минусы переноса драйвера в usespace
Плюсы:
  - Ошибка в драйвере не приводит к падению системы. 
  - Уменьшается размер TCB.
Минусы:
  - Ухудшается производительность.
  - Усложняется инфраструктурный код операционной системы для поддержки userspace драйверов.

4. Каким образом обрабатываются прерывания в системе? каким образом userspace драйвер получает и обрабатывает прерывание? Что происходит, если драйвер получает более одного прерывания, или несколько серверов хотят получить одно и то же прерывание?
В ядре операционной системы общий обработчик прерывания при возникновении прерывания посылает IPC сообщения о прерывании. Userspace драйвер получает это сообщения и обрабатывает.

5. Каким образом ядро предоставляет доступ пользовательским приложениям к портам ввода-вывода? 
Контроль доступа к портам ввода-вывода осуществляется с помощью IO Bitmap
Для доступа к портам используется IO Flexpages

6. Каким образом память устройств отображаются в пространство драйвера? 
Chipset может работать с памятью на устройстве, как с обычной физической памятью, поэтому ядро просто отображает память устройства в адресное пространство драйвера.

7. что такое virtual pci buss и каким образом работает? 
Механизм, который используется для решения проблемы множественного доступа драйверов устройств к PCI шине, к которой подключены устройства.
Вся работа с устройством выполняется через системные вызовы, который обрабатывает IO Server.

8. что такое DDE/Linux, DDEkit, что собой представляют, как работают?
DDE - Device Driver Environment
DDE/Linux - Код ядра Linux, для поддержки DDE L4
DDEkit набор общих компонентов для построения DDE конкретной операционной системы.
DDE позволяет запускать унаследованные драйверы в паравиртуализированном Linux.

9. Каким образом решена проблема множественного доступа к устройствам? (из разных серверов) 
Используется IO Server

10. что такое паравиртуализация? 
Тип виртуализации, при котором ядро гостевой ОС модифицируется, для того, чтобы запускаться в виртуализированной среде.

11. как разделены адресные пространства ядра и прикладных программ l4linux 
Ядро L4Linux и приложения Linux являются задачами пространства пользователя L4, соответственно имеют своё отдельное пользовательское адресное пространство.

12. как работают системные вызовы между прикладными программами и l4linux ядром 
Прикладная программа инициирует прерывание Int 0x80
Fiasco.OC получает CPU trap и генерирует исключение, которое представляет собой IPC сообщение с полной информацией о состоянии CPU.
Ядро Linux получает это сообщение, и обрабатывает системный вызов.

13. что такое vCPU? как он реализован? что собой представляют "kernel" и "user" в этой концепции? 
Поток ядра, который упрощает реализацию обработчиков исключений.
